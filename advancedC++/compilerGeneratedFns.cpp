
#include <iostream>


using namespace std;

class dog
{
public:

	string m_name;
	dog(string name = "Bob"){m_name = name;}	//Compiler doesn't generate default constructor as this is the default constructor
	~dog()	{...};

	dog(const dog &rhs){...}			//Copy constructor
										//Member by member initialization

	dog& operator=(const dog& rhs){...}	//Copy assignment operator
										//Member by member copying.
										//Will generate only if const or reference members not present since they need to be intialized.


	dog(){...}	//Base class Constructor if it exists. Calls member default constructor if it exists or generate one

	~dog(){...}	//Base class Destructor if it is not private

};

class dogNew()
{
	collar m_collar;
	string &m_name;		//this is not valid as references need to be initialized. this will not compile if we do a copy

	dog()="default"
}




int main(void)
{
	dog dog1("Henry");	//
	dog dog2;
	dog2 = dog1;

	return 0;
}

/*

C++ 11 rules

COMPILER GENERATES THESE FNS.

	C++ 03
	1. Default Constructor - no (Generated only if there is no constructor declared)
	2. Copy Constructor - no (Generated only if 5, 6 not declared by user)
	3. Copy Assignment Operator - yes as it is not defined (Generated only if 5, 6 not declared by user)
	4. Destructor - no

	STL container requires copy constructor and assignment operator in containee

	C++ 11
	5. Move constructor (Only if 2, 3, 4, 6 not declared by user)
	6. Move assignment operator (Only if 2, 3, 4, 5 not declared by user)

	Changes from C++ 03
	C++ 03 - If 3, 4 is declared then 2 is generated
	C++ 11 - If 3, 4 is declared but 5, 6 declared then 2 is not generated

	C++ 03 - If 2, 4 is declared then 3 is generated
	C++ 11 - If 2, 4 is declared but 5, 6 declared then 3 is not generated

*/


class Dog {

	//C++ 03
	Dog();
	Dog(const Dog&);
	Dog& operator=(const Dog&);
	~Dog();

	//C++11
	Dog(Dog&&);
	Dog& operator=(Dog&&);

};


class Cat{ //Generated by compiler for Cat -> 3, 4

	Cat(const Cat&) {} //copy constructor (2)
};


//Eg. of objects that can only be moved, not copied. Eg. sockets, mutex
class Duck { //Generated by compiler for Duck -> 4

	Duck(Duck&&) {} //Move constructor (5)
};

class Frog { //Generated by compiler for Frog -> 4

	Frog(Frog&&, int = 0) {}      //Move constructor (5)
	Frog(int = 0) {}              //Default constructor (1)
	Frog(const Frog&, int = 0) {} //Copy constructor (2)
};

class Fish { //1, 2, 3

	~Fish();
};

class Cow { //1, 2, 4 (2 is deprecated i.e. will see 2 in compiler)

	Cow& operator=(const Cow&) = delete; //copy assignment (3) declared but deleted
};


